Chapter 3: Problem Solving by Searching  (Duration: 9 hours) 3.1 Definition and State Space Search Definition of Search in AI Search is a fundamental technique in AI where an agent explores possible sequences of actions to find a path from the initial state to the goal state. The process involves systematically examining different states of the problem. State Space Representation * State: A representation of the problem at a given point (e.g., current arrangement of tiles in 8-puzzle). * Initial State: The starting point of the problem. * Goal State: The desired end condition. * Actions: Operations that transform one state to another (e.g., moving a tile in 8-puzzle). * Transition Model: Description of what each action does. * Path Cost: Numerical cost associated with a path (often sum of step costs). Example Problems 1. Water Jug Problem Problem Statement: You have two jugs, one that can hold 4 gallons (Jug A) and another that holds 3 gallons (Jug B). Neither has any measuring marks. How can you get exactly 2 gallons in Jug A? State Representation: * States can be represented as pairs (A, B) where A is the amount in Jug A and B is the amount in Jug B. * Initial State: (0, 0) * Goal State: (2, 0) or (2, 3) Possible Actions: 1. Fill a jug to its full capacity. 2. Empty a jug completely. 3. Pour water from one jug to another until either the first jug is empty or the second jug is full. Solution Path: (0,0) ? (4,0) ? (1,3) ? (1,0) ? (0,1) ? (4,1) ? (2,3) 2. 8-Puzzle Problem Problem Statement: A 3x3 board with 8 numbered tiles and one empty space. The goal is to rearrange the tiles from a given initial configuration to reach the goal configuration by sliding tiles into the empty space. State Representation: * Each state is a specific arrangement of the tiles. Possible Actions: * Move the empty space up, down, left, or right (if possible).  3.2 Solving Problems by Searching Search Strategies Search strategies can be classified based on the information available: 1. Uninformed Search (Blind Search): No additional information about states beyond what's provided in the problem definition. 2. Informed Search (Heuristic Search): Uses problem-specific knowledge to guide the search. Performance Evaluation of Search Techniques To compare different search algorithms, we use the following metrics: Metric Description Completeness Does the algorithm guarantee to find a solution if one exists? Optimality Does the algorithm find the best solution (lowest path cost)? Time Complexity How long does it take to find a solution (measured in nodes generated)? Space Complexity How much memory is required (measured in maximum nodes stored)?  3.3 Uninformed Search Techniques 1. Breadth-First Search (BFS) Description: * Expands all nodes at the current depth before moving to nodes at the next depth level. * Uses a queue to manage nodes (FIFO). Properties: * Complete: Yes, if the branching factor is finite. * Optimal: Yes, if all actions have the same cost. * Time Complexity: O(b^d), where b is branching factor, d is solution depth. * Space Complexity: O(b^d) (keeps all nodes in memory). Example: Finding the shortest path in an unweighted graph.  2. Depth-First Search (DFS) Description: * Expands the deepest node first. * Uses a stack to manage nodes (LIFO). Properties: * Complete: No (may get stuck in infinite loops). * Optimal: No (may find a non-optimal solution first). * Time Complexity: O(b^m), where m is maximum depth. * Space Complexity: O(b*m) (only stores current path). Example: Solving puzzles like the 8-queens problem.  3. Depth-Limited Search (DLS) Description: * DFS with a depth limit l. Nodes at depth l are treated as if they have no successors. Properties: * Complete: No (if l < d). * Optimal: No. * Time Complexity: O(b^l). * Space Complexity: O(b*l). Example: Used in games with limited look-ahead. 4. Bidirectional Search Description: * Runs two simultaneous searches: one forward from the initial state and one backward from the goal. Properties: * Complete: Yes, if both searches are BFS. * Optimal: Yes, if both searches are BFS. * Time Complexity: O(b^(d/2)). * Space Complexity: O(b^(d/2)). Example: Finding the shortest path between two points in a map.   3.4 Informed Search Techniques 1. Greedy Best-First Search Description: * Expands the node that appears closest to the goal, based on a heuristic function h(n). Properties: * Complete: No (may get stuck in loops). * Optimal: No. * Time Complexity: O(b^m). * Space Complexity: O(b^m). Example: Finding a path in a city using straight-line distance as the heuristic. 2. A?Search* Description: * Combines the cost to reach the node g(n) and the estimated cost to the goal h(n) using f(n) = g(n) + h(n). Properties: * Complete: Yes, if h(n) is admissible. * Optimal: Yes, if h(n) is consistent. * Time Complexity: Exponential in worst case. * Space Complexity: Keeps all nodes in memory. Example: Pathfinding in games like Pac-Man. 3. Hill Climbing Description: * Iteratively moves to a neighboring state with higher value (like climbing a hill). Properties: * Complete: No (gets stuck in local maxima). * Optimal: No. * Time Complexity: Depends on the landscape. * Space Complexity: O(1). Example: Optimizing a mathematical function. 4. Simulated Annealing Description: * Inspired by annealing in metallurgy. Allows "bad" moves to escape local optima. Properties: * Complete: Yes, with appropriate cooling schedule. * Optimal: Yes, with appropriate cooling schedule. * Time Complexity: Depends on cooling schedule. * Space Complexity: O(1). Example: Solving the traveling salesman problem.   3.5 Constraint Satisfaction Problems (CSPs) Definition A CSP is defined by: * Variables: e.g., Sudoku cells. * Domains: Possible values for each variable (e.g., 1-9). * Constraints: Rules that define allowable combinations (e.g., no duplicates in a row). CSP Search Techniques 1. Backtracking: Assigns values to variables and backtracks when a constraint is violated. 2. Forward Checking: Reduces domains of unassigned variables to maintain consistency. 3. Arc Consistency: Ensures all pairs of variables satisfy constraints. Example: * Sudoku: Variables = cells, Domain = 1-9, Constraints = row/column/box rules.   Summary * Uninformed Search: BFS, DFS, etc. — no heuristic data. * Informed Search: A*, Greedy — uses heuristics for efficiency. * CSPs: Solved via constraint propagation and backtracking.  Learning Outcomes ? Compare uninformed vs. informed search strategies. ? Implement A* and constraint satisfaction algorithms. ? Evaluate search performance using completeness/optimality.  Key Formulas * A?Evaluation: f(n) = g(n) + h(n) o g(n): Path cost from start. o h(n): Heuristic estimate to goal.  